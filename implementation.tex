\chapter{Implementation}
\label{chapter:implementation}

This chapter addresses the main decisions adopted regarding the implementation of the IDChain, vanilla an CA-based systems. Therefore, the following sections cover the technologies that were used in the development process and the implementation details of each component.

\section{Adopted Technologies}

In this section we will present the chosen technologies to implement the proposed work, for each component of the architecture.

\subsection{DHT}

In a first instance, the chosen library to implement the DHT node was \textit{TomP2P}\footnote{http://tomp2p.net/} a implementation of Kademlia in Java.
The use of TomP2P was already decided before-hand, since the Global Registry component in the reThink project, was already partially implemented using it.
This restricted the implementation options from the get-go, since it wasn't possible to compare different \ac{DHT} implementations and check which one could be more easily extended.

We tried to modify the TomP2P source code, and implement TLS connection supports.
This endeavor didn't succeeded, mainly since the TomP2P code is tightly coupled to TCP and UDP connections.
Since TomP2P uses \textit{Netty}\footnote{https://netty.io/}, a Java NIO client-server \ac{NIO} framework, we tried to to change Netty instance calls to TLS, a try which revealed infeasible.

Therefore we decided to implement the mechanisms using another DHT system.
Several DHT implementations exist in different languages, but was necessary to pin down an implementation that had a modular architecture and could be easily extended.

The implementation that revealed to be the most modular was the one of \textit{Kad}\footnote{https://kadtools.github.io} library, for \textit{Node.js}\footnote{https://nodejs.org/} and based on Kademlia.
This implementation allows to easily extend the base DHT with custom transports, middleware, storage layers and message processors, which enabled us to build a custom transport with TLS mutual-authentication and custom verification rules.

The same DHT client was used for the three different mechanisms: vanilla, CA-based and IDChain.
Is possible to switch between the three different mechanisms by declaring in the configuration file which one we want to use.

\subsection{Blockchain}

The blockchain that we used is Ethereum.
The are a number of other blockchains currently available that enable developers to build applications on top of it using smart contracts, like Hyperledger Fabric\cite{cachin2016architecture} or R3 Corda\cite{mikehearn2016}, but these implementations have more specific use-cases, enterprise and finances respectively.

A quick analysis between these three platforms show significant architectural differences, in such a way that we can even consider an higher-level classification for these  three platforms, since not all of them show the main characteristics of a blockchain (taking in consideration the Bitcoin reference paper).
A broader definition that encapsulates this three platforms is \ac{DLT}.

The Hyperledger Fabric platform has a modular approach to blockchains. It's a private blockchain system  and is permissioned, i.e doesn't allow unknown entities to participate in the system.
To participate in the system the members of a Hyperledger Fabric system, must enroll through a \ac{MSP}.
This allows different architectural approaches in the system, because is not strictly necessary to have a \ac{POW} mechanism, like in Ethereum or Bitcoin (which may be considered open networks), and is possible to use different consensus mechanisms in the network.
Also, there isn't any built-in currency like in Bitcoin or Ethereum.

The R3 Corda system is considered a \ac{DLT} for financial institutions.
Is also permissioned and private, and uses a concept of notary nodes to validate uniqueness of transactions. Like Fabric, also allows a more fine-grained control of the consensus mechanism.
Data is shared on a need-to-know basis, there is no global broadcast of all the transactions in the system.

Finally, the Ethereum platform is the more generic blockchain platform of the ones referenced.
Is permission-less, and can be public or private.
All the participants have to achieve consensus over all the transactions of the system, using the \ac{POW} consensus and leveraging the built-in currency (ether).

Our choice was Ethereum due to a number of reasons:

\begin{itemize}
	\item Permissionless - even thought we want to build our mechanism around a federated/enterprise model, this proof of concept may be easily adapted to be used as a global system.
  Since the Ethereum network is public, and we could also deploy private instances, it is the right fit.
	\item Developer ecosystem - right now, Ethereum has the biggest developer community, with a increasing number of development tools to aid the development and deploy process of smart contracts.
\end{itemize}

Even thought the Ethereum network is currently the system with the better developer ecosystem, there are still several shortcomings when developing against it.
In Section~\ref{implementation:idchain} we detail some of the difficulties and shortcomings of the Ethereum smart contracts.

\subsection{API}

\subsubsection{Application Server}

\subsubsection{Database}


\subsection{Management Application}



\section{Vanilla system}


\section{CA-based system}


\section{IDChain system}\label{implementation:idchain}

\subsection{Smart contract}

\subsection{API}

\subsection{Application}
