\chapter{Implementation}
\label{chapter:implementation}

This chapter addresses the main decisions adopted regarding the implementation of the IDChain, vanilla an CA-based systems. Therefore, the following sections cover the technologies that were used in the development process and the implementation details of each component.

\section{Adopted Technologies}

In this section we will present the chosen technologies to implement the proposed work, for each component of the architecture.

\subsection{DHT}

In a first instance, the chosen library to implement the DHT node was \textit{TomP2P}\footnote{http://tomp2p.net/} a implementation of Kademlia in Java.
The use of TomP2P was already decided before-hand, since the Global Registry component in the reThink project, was already partially implemented using it.
This restricted the implementation options from the get-go, since it wasn't possible to compare different \ac{DHT} implementations and check which one could be more easily extended.

We tried to modify the TomP2P source code, and implement TLS connection supports.
This endeavor didn't succeeded, mainly since the TomP2P code is tightly coupled to TCP and UDP connections.
Since TomP2P uses \textit{Netty}\footnote{https://netty.io/}, a Java NIO client-server \ac{NIO} framework, we tried to to change Netty instance calls to TLS, a try which revealed infeasible.

Therefore we decided to implement the mechanisms using another DHT system.
Several DHT implementations exist in different languages, but was necessary to pin down an implementation that had a modular architecture and could be easily extended.

The implementation that revealed to be the most modular was the one of \textit{Kad}\footnote{https://kadtools.github.io} library, for \textit{Node.js}\footnote{https://nodejs.org/} and based on Kademlia.
This implementation allows to easily extend the base DHT with custom transports, middleware, storage layers and message processors, which enabled us to build a custom transport with TLS mutual-authentication and custom verification rules.

The same DHT client was used for the three different mechanisms: vanilla, CA-based and IDChain.
Is possible to switch between the three different mechanisms by declaring in the configuration file which one we want to use.

\subsection{Blockchain}

The blockchain that we used is Ethereum.
There are a number of other blockchains currently available that enable developers to build applications on top of it using smart contracts, like Hyperledger Fabric\cite{cachin2016architecture} or R3 Corda\cite{mikehearn2016}, but these implementations have more specific use-cases, enterprise and finances respectively.

A quick analysis between these three platforms show significant architectural differences, in such a way that we can even consider an higher-level classification for these three platforms, since not all of them show the main characteristics of a blockchain (taking in consideration the Bitcoin reference paper).
A broader definition that encapsulates this three platforms is \ac{DLT}.

The Hyperledger Fabric platform has a modular approach to blockchains. It's a private blockchain system  and is permissioned, i.e doesn't allow unknown entities to participate in the system.
To participate in the system the members of a Hyperledger Fabric system, must enroll through a \ac{MSP}.
This allows different architectural approaches in the system, because is not strictly necessary to have a \ac{POW} mechanism, like in Ethereum or Bitcoin (which may be considered open networks), and is possible to use different consensus mechanisms in the network.
Also, there isn't any built-in currency like in Bitcoin or Ethereum.

The R3 Corda system is considered a \ac{DLT} for financial institutions.
Is also permissioned and private, and uses a concept of notary nodes to validate uniqueness of transactions. Like Fabric, also allows a more fine-grained control of the consensus mechanism.
Data is shared on a need-to-know basis, there is no global broadcast of all the transactions in the system.

Finally, the Ethereum platform is the more generic blockchain platform of the ones referenced.
Is permission-less, and can be public or private.
All the participants have to achieve consensus over all the transactions of the system, using the \ac{POW} consensus and leveraging the built-in currency (ether).

Our choice was Ethereum due to a number of reasons:

\begin{itemize}
	\item Permissionless - even thought we want to build our mechanism around a federated/enterprise model, this proof of concept may be easily adapted to be used as a global system.
  Since the Ethereum network is public, and we could also deploy private instances, it is the right fit.
	\item Developer ecosystem - right now, Ethereum has the biggest developer community, with a increasing number of development tools to aid the development and deploy process of smart contracts.
\end{itemize}

Even thought the Ethereum network is currently the system with the better developer ecosystem, there are still several shortcomings when developing against it.
In Section~\ref{implementation:idchain} we detail some of the difficulties and shortcomings of the Ethereum smart contracts we encountered during development.

\subsection{IDChain API}

\subsubsection{Application Server}

The IDChain API is build using the Node.js Javascript runtime using some frameworks and libraries:

\begin{itemize}
  \item \textit{Hapi}\footnote{https://hapijs.com/} - web framework for building web applications, RESTful APIs and services;
  \item \textit{web3.js}\footnote{https://github.com/ethereum/web3.js/} - the Ethereum compatible Javascript API;
  \item \textit{Sequelize}\footnote{https://sequelizejs.com} - a \ac{ORM} for Node.js which support several SQL dialects.
\end{itemize}

The decision of using Node.js to develop the HTTP API is mainly related with the web3.js library.
At the time of development was the most mature library to interface with the Ethereum client.
The Ruby, Java and .Net implementations were still in early stages of development.

% verificar isto
The Hapi framework was chosen because allows to build APIs encapsulating APIs endpoints around a plugin system. For example, is possible to create a plugin that encapsulates all the endpoints that are related with the certificates domain.
This allow to compose the API using tiny modules that contain the business logic of each domain in the application, which later could be easily decoupled and deploy separately.
Also Hapi has already a couple of modules built-in for dealing with input and response validation, error handling, session caching, logging, etc.

We decided to use an \ac{ORM} to interact with the database due to the following reasons:

\begin{itemize}
  \item Allows easier implementation of the entities in the API;
  \item Leads to a huge reduction in code, since eliminates the need for repetitive SQL queries;
  \item Easier navigation of entities relationships;
  \item Transaction management and isolation;
  \item Independent of the SQL database or dialect used,  allowing to use any SQL database or dialect.
\end{itemize}

We decide to use the Sequelize ORM, since is the most mature and fully-fledge SQL ORM for Node.js.

\subsubsection{Database}

\subsection{Management Application}

\section{Vanilla system}


\section{CA-based system}


\section{IDChain system}\label{implementation:idchain}

\subsection{Smart contract}

\subsection{API}

\subsection{Application}
