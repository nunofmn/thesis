\chapter{Architecture}
\label{chapter:architecture}

This chapter describes the overall architecture of IDChain and outlines its main functional components.
The main design goal is to allow to build a fully decentralized DHT-based system that is secure and can be closed to participation in a federated model, while minimizing trust in the intervenients.
The main design goal is to allow to build a fully decentralized DHT-based system that is secure and can be closed to participation in a federated model, while minimizing trust in the intervenients.
We introduce the main requirements in Section~\ref{architecture:requirements} and give a system architecture overview in Section~\ref{architecture:overview}.
The remaining sections describe the in more detail the architecture of the solution and discuss the main design choices.

\section{Requirements}\label{architecture:requirements}

\section{Overview}\label{architecture:overview}
The proposed architecture will consist of two independent, inter-connected systems:

\begin{itemize}
	\item \textbf{Distributed Hash Table} based on Kademlia;
	\item \textbf{Decentralized Public Key Infrastructure} (DPKI) built on top of the blockchain.
\end{itemize}


In Figure~\ref{fig:architecture-overview} an high-level overview of the architecture is shown.
In Section~\ref{ssec:dht} and~\ref{ssec:blockchain} an in-depth description of each individual component is given.

As can be seen in Figure~\ref{fig: archtecture-overview} the two main components are the \ac{DHT} and the \ac{DPKI}.

The DPKI can be subdivided in three main components:
\begin{itemize}
	\item \textbf{Blockchain};
	\item \textbf{IDChain API};
	\item \textbf{IDChain Application};
\end{itemize}

\begin{figure}
  \includegraphics[width=\linewidth]{Figures/architecture-overview.pdf}
    \caption{Overview of solution architecture.}
    \label{fig:architecture-overview}
\end{figure}

In the scope of the current reTHINK project architecture, these components will be only used in a federated model, i.e the nodes in the \ac{DHT} will all belong to the Service Providers (SP).
Therefore it is possible to assume some level of trust with the nodes, which opens the possibility to use a more traditional approach for managing the certificates, for exxample, a Certificate Authority.
But, in a federated model we might want to minimize trust in other organizations or SP, in order to discourage fradulent activity or over-control of the system by one or several organizations.
\acp{CA} have also the problem of adding an extra burden in organizations, since is not a totally automated system and still need some human intervention, mainly when accepting and signing \acp{CSR}.

%but the proposed architecture tries to maximize the security to a level, where it could be possible to allow anyone to participate in the network with some minor adjustments.

\section{Distributed Hash Table} \label{ssec:dht}
%The DHT design and implementation will be performed by another reTHINK project member, so there will only be a focus in the security and reliability of the DHT.

The DHT that will be deployed will be based on a Kademlia protocol implementation.
This implementation should already ensure data republishing and replication.

Each node in the DHT will have a self-signed certificate that is needed to ensure a secure routing message exchange between nodes in the overlay network.
When a node is routing a message through the overlay network, the peer connectivity is done using TLS connections with mutual authentication, so that the two peer certificates can be exchanged and verified.
In order to verify the authenticity of the certificate, the peer identifier of the message sender should be equal to the peer identifier in the sender certificate.
But this verification is not sufficient to guarantee the validity of the certificate, since a peer this way can impersonate several identities.
So is necessary to implement a mechanism similar to certificate pinning.
Therefore the peer should also check if there is a correspondence between the certificate fingerprint and the peer identifier registered in the blockchain.

%It will also add its digital signature of the data contents in order to verify data integrity and validity, and a nonce to prevent against replay attacks.

%CHECK THIS
%Each new user in the \textit{Registry} system will also need to generate a key pair and send his current SP the public key. The SP will ensure that a user certificate with the user public key is created in the blockchain.
%Users when storing the data in the DHT will also store the digital signature of the data, created with their private key.

%When a user runtime needs to obtain a specific user data, it will also contact the SP, in order to obtain the user certificate and verify the data signature. A secure communication between the SP and user runtime is assumed.

\section{Decentralized Public Key Infrastructure} \label{ssec:blockchain}

Estabilishing \ac{TLS} connections between nodes requires trusting the exchanged peers certificates during the \ac{TLS} connection handshake.
In a traditional setup the underlying \ac{PKI} and \acp{CA} guarantee that the certificates are trustworthy, since the \acp{CA} sign the certificates.
If the peer trusts the \ac{CA} that signed off the certificate and have access to the \ac{CA} certificate, it's able to verify the other peers certificates.

But if we want to minimize trust and build a fully decentralized model, trusting in a centralized entity like a \ac{CA} defeats that purpose.
Another mechanisms exist that try to decentralize this trust model, for instance, web of trust models, in systems like \ac{PGP}, where users sign assertions for each other keys or certificates.

Still, most of the times \ac{PGP} users still rely in a centralized mechanism, key servers, for distributing certificates or keys.

In order to obtain these certificates securely and verify their authenticity, in a totally decentralized manner without needing a CA, we are going to build a Decentralized Public Key Infrastructure (DPKI) using smart contracts in a blockchain.

The DPKI will have the following functionalities:
\begin{itemize}
	\item Register and store certificates associating a node identifier with its certificate fingerprint;
	\item Revoke compromised certificates;
	\item Allow users to query the blockchain, in order to retrieve the associations between node identifiers and certificate fingerprint.
\end{itemize}

Since we want to build this DPKI mechanism on top of TLS, complementing it, we will use some mechanisms that are used in \textit{Certificate Pinning}\footnote{https://www.owasp.org/index.php/Certificate\_and\_Public\_Key\_Pinning}.

In the following sub-sections a more detailed overview of each piece of the \ac{DPKI} architecture will be given.

\subsection{IDChain Smart Contract}

The logic and set of rules that compose the \ac{DPKI} are stored in a blockchain smart contract.
The smart contract that we gonna to create has the main objective of associate an peer identifier to a valid certificate, in a way that any system can easily query for and verify that association.

\subsubsection{Trusted Certification}
Creating this association is a sufficient condition to guarantee the validity and authenticity of a peer certificate, but we also need to be able to restrict and control the participation in the \ac{DHT}, in order to be able to create a mechanism of defense against Sybil attacks.
The starting point are the conclusions drawn by Douceur\cite{Douceur2002} that trusted certification is the only approach that has the potential to eliminate Sybil attacks, however this certification relies on a centralized entity.

\subsubsection{Smart Contracts and Autonomy}
Although, with the advent of the blockchain technologies and smart contracts, is possible to build entities and organizations like the DAO~\cite{ralphc.merkle2016}, entities that are truly transparent, that can't be stopped or interrupted, and more importantly can't be corrupted or tampered.
The rules and code that dictate the behavior of this entities, could be defined by a smart contract deployed in a blockchain.

This way, leveraging this technologies, is possible to build a system that decentralizes the trusted certification mechanism.

A good starting point is encoding a hard limit on the number of identifiers or certificates, that an entity can associate with their own blockchain address.

We can also opt by a soft limit or resource-based approach, for example, by imposing the payment of a value for each certificate association created, leveraging the cryptocurrency inherently associated with the blockchain system.

\subsubsection{Smart Contract Logic}
The main starting point the smart contract is the \textit{Certificate} structure and fields.
In Figure~\ref{fig:certificate-structure}, is depicted the necessary fields in this structure.
Note that is not necessary to save the full certificate metadata in the blockchain: the certificates are already exchanged in the TLS handshake between the nodes.
Could be possible to save all the certificate metadata or even the full encoded certificate for searchability and navigability proposes, but blockchains are not appropriated to save large quantities of information.
Not only blockchains have a maximum ammount of data that can be encoded in a block and transaction, also in the case of a blockchain as Ethereum, the cost of storing full certificates in the blockchain would be very high.
Still, if this functionality was necessary and we wanted to maintain a decentralized system, a better approach would be store the full certificate in a \ac{p2p} filesystem like \ac{IPFS}, and store in the \textit{Certificate} structure the address hash of the certificate.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{Figures/certificate-structure.pdf}
  \caption{Smart contract \textit{Certificate} structure fields.}
\label{fig:certificate-structure}
\end{figure}

Since we are trying to build this \ac{DPKI} under a federated model, is still necessary to define the trust mechanism in this system.
So we are building the trust mechanism relying on a web of trust model built on top of the blockchain.

As is shown in Figure~\ref{fig:web-of-trust-architecture}, a newly created entity to be accepted should be vouched by a minimum number of entities.
One peculiar aspect of this architecture, consequence of the federated model, is that each entity in the system is able to create several node certificates.
This can undermine smaller entities participating in the system, and could even allow one single entity to control the whole \ac{DHT}, by generating unlimited node certificates.
% reformular esta frase %
A combination of an hard limit, for example, a maximum number of certificates each entity can have, and a soft limit, i.e defining a cost, using the underlying cryptocurrency, for each certificate, could provider a equal and fair system for all the entities involved.

\begin{figure}
  \includegraphics[width=\linewidth]{Figures/web-trust-main.pdf}
  \caption{Web of trust mechanism.}
\label{fig:web-of-trust-architecture}
\end{figure}

Defining the web of trust mechanism in the smart contract requires the creation of an \textit{Entity} structure.
In Figure~\ref{fig:entity-structure} are defined the necessary fields.
Is important to note that the entities addresses that an entity vouched for (\textit{signed} field) and the entities addresses that vouched for our own entity (\textit{signers} field) are stored in this entity, because will be necessary to constantly calculate the state of each entity.
If we considered a graph representation (usual in the web of trust model), this fields encode the inbound arrows and outbound arrows of each entity.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{Figures/entity-structure.pdf}
  \caption{Smart contract \textit{Entity} structure fields.}
\label{fig:entity-structure}
\end{figure}

Another important aspect to take into account when building this smart contract is the bootstrapping process.
In order to the web of trust mechanism to work is necessary to define the initial entities which are trusted.
Since we are in an federated model, the entities that will deploy the smart contract could prearrange the entities that will be trusted from the beginning.
Another possible solution, which we will use, is to give a trust status to the first \textit{n} entities that will register in the smart contract.
The entities that are given this initial trust will have a \textit{true} value in the \textit{bootstraper} field.

The minimum functionalities or functions that the smart contract should provider are:

\begin{itemize}
  \item \textbf{Register a new entity} - this function should init a new entity associated with the blockchain account that called the function;
  \item \textbf{Create a new certificate} - generate a new certificate with the given fields in the blockchain, creating also the respective associations with the entity generating it;
  \item \textbf{Revoke the certificate} - ;
  \item \textbf{Vouch for entity} - ;
  \item \textbf{Unvouch for entity} - ;
  \item \textbf{Check entity validity} - ;
\end{itemize}

% TODO: Describe the main functions of the smart contract

\subsubsection{Web of trust scenarios}

\begin{figure}
  \includegraphics[width=\linewidth]{Figures/entity-structure.pdf}
  \caption{Smart contract \textit{Entity} structure fields.}
\label{fig:entity-structure}
\end{figure}

\subsection{IDChain API}

\subsection{IDChain Application}

\section{Overlay network processes}

\subsection{Node bootstrap and registration}
During the node bootstrap process, the node will have to create an account in the private Ethereum blockchain i.e an external owned account, obtaining a private key.
The Ethereum account will be controlled by this private key, which the node will use to call the methods of the contracts that implement the DPKI.

After the Ethereum account creation the node will need to generate the public-key pair necessary for node communication.
The generated public key will be associated with the node Ethereum account address by calling the \textit{newCertificate} function in the \textit{CertificateList} contract, that will create a certificate and store it in the \textit{contract account} internal storage.
Finally the node will enter the DHT network using a node identifier equal to its Ethereum account address.

Since the DHT is based on Kademlia, having a 160-bit address space, and Ethereum accounts have also a 160-bit address space, this direct mapping between the two components identifiers is possible.

This process is summarized in Figure~\ref{fig:new-node}.

\begin{figure}
    \includegraphics[width=\linewidth]{Figures/new-node.png}
    \caption{New node entry in the DHT.}
    \label{fig:new-node}
\end{figure}

\subsection{Node message routing}
Every time a node needs to send a message to another node, it will first fetch the destination node certificate from the blockchain by its node identifier.

After fetching the key, the node will digitally sign the data with its own private key, add a nounce, encrypt them in conjunction with message data and send it to the destination node.

When receiving a message, a node will fetch the sender certificate from the blockchain, decipher the encrypted message data with its own private key and verify the digital signature of the data, using the sender public key.
If a node is unable to find the certificate associated with the node that is contacting, it will discard the node from its routing table.

In Figure~\ref{} the message routing functionality is diagrammed.

\begin{figure}
    \includegraphics[width=\linewidth]{Figures/message-routing.png}
    \caption{Message routing between nodes.}
    \label{fig:message-routing}
\end{figure}

Always fetching the certificates from the blockchain could incur in a increased delay in message routing.
Therefore the nodes will cache the fetched certificates, and regularly (every 5 minutes for example) fetch the CRL from the blockchain, to ensure the freshness of the public keys.

\subsection{Users certificates management}
The SP nodes will also need to manage the users certificates, allowing them to register and revoke public keys.

When receiving a new user public key, the SP node will create an user certificate in the blockchain, where the issuer is the contacted SP node.

If a user need to revoke the public key, it will send an revocation request to the SP node, which will revoke the certificate stored in the blockchain.

\subsection{Eclipse and Sybil attacks defense}
The mitigation of possible Sybil and Eclipse attacks leverage the Ethereum cryptocurrency.

The execution of the certificate creation process in the blockchain will require the payment of a value in ether, defined by the contract creator, which will be saved in the \textit{contract account} balance.
If an attacker tries to launch a Sybil attack, he will need to pay an enormous amount of ether, making the attack infeasible.
Since the execution of any contract in Ethereum requires the payment of ether, to avoid retaining the funds, the contract could auto-trigger an event that will equally distribute the funds to the nodes in the network.

This solution will also help mitigate possible Eclipse attacks, since preventing Sybil attacks is a constraint to launch Eclipse attacks.
Coupled with the Kademlia k-bucket replacement policy, where new nodes are only added if a bucket is not full and parallel routing, an efficient defense against Eclipse attacks is achieved.

\subsection{Data replication}
When a DHT node receives a request to store user data, is necessary to ensure data replication, in order to achieve data availability.
The implemented DHT will use TomP2P direct replication method. In this method a node constantly republishes its own content to other nodes, and its responsible for its content.
In case of node failure, the content may timeout and be removed, but since the DHT node run in a SP, a fast restart of the DHT node is assumed.

\section{Comparison with a CA}
Using a blockchain to build a PKI, is possible to minimize the trust, relatively to a centralized solution, like a CA.
% time ordered?
Due to the nature of the blockchain as an immutable transactional database, is possible to guarantee the validity of each transaction, through inspection of the past ones.
This immutability property also allows to perform audits to the blockchain, in order to verify the integrity of the data stored.
The biggest disadvantage of the blockchain is the computational resources needed to guarantee its proper operation and security.
